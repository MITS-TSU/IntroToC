## Массивы

### Task 1. Проба пера
###### 100 points

Пользователь через пробел вводит N чисел. Занесите их в массив. После конца ввода выведите последовательность задом наперед.  
N объявите в программе в виде константы.

Вход:
 - x1 x2 x3 ... xn

Выход:
 - xn xn-1 ... x2 x1

### Task 2. Бикини боттом
###### 200 points

Создайте масси из N чисел. Заполните его случайными значениями от 0 до 255. Используйте функцию `rand() & 0xff`.
Выведите массив на экран. Поменяйте элементы местами так, чтобы они шли в порядке возрастания. Попробуйте придумать свой алгоритм.
Если не получится - используйте [это](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC)
![image](https://user-images.githubusercontent.com/23273750/111192097-4bc5e000-85eb-11eb-97df-619288274354.png)


### Task 3*. Правило 34
###### 300 points

[Клеточные автоматы](https://ru.wikipedia.org/wiki/Правило_30) - невероятно крутая в своей простоте штука.
1. Создайте массив A длины N (N - нечетное). Заполните его нулями везде кроме середины (N / 2 + 1). В середине поставьте единицу
2. Выведите массив A
3. Создайте массив B длины N. Заполните его нулями.
4. Создайте указатели `a` (&A) и `b` (&B)
5. Заполните массив на который указывает `b` по следующему правилу:  
   a. Для вычисления bi используются значения _триады_ из массива на который указывает `a`.
   ```
   a[i-1] a[i] a[i+1]
      |     |     |
      └-----|-----┘
           rule
            |
   ...    b[i]    ...
   ```
   b. На вход rule попадает 3 бита. Например (101, 000, 111, 001 и т.д.)  
   c. Эти 3 бита преобразуются в число от 0 до 7 (101 - 5, 000 - 0, и т.д.). Назовем это число x  
   d. rule это на самом деле какая-то константа от 0 до 255 (для начала возьмите `rule = 30`)  
   e. Возьмите бит под номером x из числа rule. (Сделать это можно в две операции - битовый сдвиг и конъюнкция)  
   f. Получившийся бит и будет новым значением в b[i]  
5. Выведите массив B
6. Поменяйте указатели местами. (Так что `a` станет указывать на `B`, а `b` на `A` или наоборот)
7. Перейдите на шаг 5

Как вы могли догадаться, получается цикл. Выполните его какое-нибудь фиксированное число раз, или используйте `while (1)` и `usleep(100 * 1000)` (нужно будет подключить `#include<time.h>`)  
Попробуйте позапускать программу с разными значениями rule - например `[30, 110, 45, 60, 62, 72, 73, 74, 75, 82, 86, 88, 89, 90, 94, 101, 102, 104, 105, 106, 108, 109, 118, 120, 126, 134, 138, 144, 146, 148, 150, 166, 180, 182, 210]`
Попробуйте модифицировать вывод, чтобы выводились не 1 / 0 а какие-нибудь значки. Например пробел и `#`
![image](https://user-images.githubusercontent.com/23273750/111195807-3a7ed280-85ef-11eb-83e3-bef8dad6ddf1.png)
